<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta name="copyright" content="Copyright (c) 2012 EclipseSource. This page is made available under license. For full details see the LEGAL in the documentation book that contains this page."/>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Multi User Enviroment</title>
  <link rel="stylesheet" href="../../../../PRODUCT_PLUGIN/book.css" type="text/css"/>
</head>
<body>

  <h1>Understanding Scopes In RAP</h1>

  <p>
    In a desktop environment, an instance of an application normally serves only a single user,
    runs in its own Java VM instance, and the operating system usually provides a user-specific
    storage on the file system.
    For RAP applications, things are very different.
  </p>
  <p>
    A RAP application does not own the VM. It runs on a server and shares the VM with the servlet
    container, other applications, maybe even other RAP applications.
    There are multiple users accessing the application, each one with a separate UI, but all sharing
    the same classes.
    Moreover, a RAP application runs for a very long time.
    When a user logs in, the application is already running, and it continues to run when the user
    leaves.
    For that reason, it is necessary to distinguish several scopes when designing RAP applications.
  </p>

  <h2>Application Scope</h2>
  <p>
    There can be more than one RAP application running at the same time, e.g. on different network
    ports or different contexts paths.
    Every application has its own set of entry points, registered resources, and so on.
    All these things have application scope.
    If you have objects that should be accessible from everywhere in the application, they need to
    have session scope as well.
    RWT provides an application-scoped store for these objects, called <em>application store</em>,
    that can be accessed using <code>RWT.getApplicationStore()</code>.
  </p>

  <h2>Session Scope</h2>
  <p>
    RAP builds user sessions on top of the servlet container's session management.
    But in contrast to the underlying HTTP session, a user session in RAP spans exactly one
    execution of an entrypoint.
    As an example, when the browser is refreshed (usually by hitting <em>F5</em>) to start over,
    the user still has the same HTTP session, but a fresh RAP session.
    RAP also provides a session-scoped data store, the <em>session store</em>, accessible using
    <code>RWT.getSessionStore()</code>.
    The session store also provides access to the HTTP session.
    Note that the session store can not be accessed directly from a background thread.
    <!-- 
     See example below.
     -->
    For working with session-unique singletons, see <a href="#singleton">Session Singleton</a>.
  </p>

  <h3>Session Timeout</h3>
  <p>
    A RAP session ends when the execution of an entrypoint is finished or when the underlying
    HTTP session times out.
    The timeout interval must be be configured with the servlet container.
    For web applications, this can be done in the web application's deployment descriptor (web.xml):
  </p>
  <pre><code>&lt;session-config&gt;
  &lt;session-timeout&gt;30&lt;/session-timeout&gt;
&lt;/session-config&gt;
  </code></pre>
  <p>
    The timeout value can also be changed programmatically on a per session basis:
  </p>
  <pre><code>RWT.getSessionStore().getHttpSession().setMaxInactiveInterval(&lt;timeout in Seconds&gt;);
  </code></pre>
  <p>
    Note that when using the RAP launcher, by default a session never expires. To change the value,
    adjust the setting on the <em>Main</em> tab.
  </p>

  <h3>Session Cleanup</h3>
  <p>
    To cleanup session-scoped objects, a <code>SessionStoreListener</code> can be registered with
    the the session store:
  </p>
   <div dir="ltr" style="text-align: left;"><pre><code>RWT.getSessionStore().addSessionStoreListener( new SessionStoreListener() {
  public void beforeDestroy( SessionStoreEvent event ) {
    // Perform cleanup        
  }
} );
   </code></pre></div>
  <!-- 
  <p>
    There are several ways to do some cleanup before the session is destroyed. The first choice
    in most cases is to attach an <code>SWT.Close</code> listener to the Display or register a
    Runnable with disposeExec(): 
  </p>

   <div dir="ltr" style="text-align: left;"><pre><code>display.addListener( new Listener() {
  public void handleEvent( Event event ) {
    // Perform cleanup        
  }
} );
display.disposeExec( new Runnable() {
  public void run() {
    // Perform cleanup
  }
} );
   </code></pre></div>
   -->

  <h2>Request Scope</h2>
  <p>
    A third scope in RAP spans the processing of a single request.
    There is also a request-scoped store available, called <em>service store</em>, which can be
    accessed using <code>RWT.getServiceStore()</code>.
    Normally, this scope is not relevant for RAP application development.
  </p>

  <h2>Persisting User Data</h2>
  <p>
    RWT provides a persistent data store called SettingStore, which can be accessed using
    <code>RWT.getSettingStore()</code>.
    The settings store uses a cookie to identify a returning user.
    By default, the cookie expires after 3 months, but may also be deleted by the user before then.
  </p>

  <h2>Data Stores (Overview)</h2>
  <table border="1" cellpadding="3" cellspacing="0">
    <tr>
      <th align="left">Store</th>
      <th align="left">Access</th>
      <th align="left">Scope</th>
      <th align="left">cleared</th>
    </tr>
    <tr>
      <td><code>IApplicationStore</code></td>
      <td><code>RWT.getApplicationStore()</code></td>
      <td>application</td>
      <td>when application is stopped/restarted</td>
    </tr>
    <tr>
      <td><code>ISessionStore</code></td>
      <td><code>RWT.getSessionStore()</code></td>
      <td style="white-space:nowrap">session</td>
      <td>when session expires</td>
    </tr>
    <tr>
      <td><code>IServiceStore</code></td>
      <td><code>RWT.getServiceStore()</code></td>
      <td style="white-space:nowrap">request</td>
      <td>when HTTP response is sent to client</td>
    </tr>
    <tr>
      <td><code>ISettingsStore</code></td>
      <td><code>RWT.getSettingStore()</code></td>
      <td>user (persistent)</td>
      <td>never, cookie lasts 3 month by default</td>
    </tr>
  </table>

  <!-- 
  <p>
    Example for accessing the HTTP session / session store from a background thread: 
  </p>
  <div dir="ltr" style="text-align: left;"><pre><code>final Display display = new Display();
final Runnable bgRunnable = new Runnable() {
  public void run() {
    UICallBack.runNonUIThreadWithFakeContext( display, new Runnable() {
      public void run() {
        Object someValue = RWT.getSessionStore().getAttribute( "myAtt" );
        System.out.println( someValue );
        // access the HTTP session
        RWT.getSessionStore().getHttpSession();
      }
    } );
  }
};
Shell shell = new Shell( display );
Button button = new Button( shell, SWT.PUSH );
button.setText( "Start Background Thread" );
button.addSelectionListener( new SelectionAdapter() {
  public void widgetSelected( final SelectionEvent evt ) {
    RWT.getSessionStore().setAttribute( "myAtt", "someValue" );
    Thread thread = new Thread( bgRunnable );
    thread.setDaemon( true );
    thread.start();
  }
} );
  </code></pre></div>
   -->

  <h2>Singletons and Static Fields</h2>
  <p>
    The classical singleton pattern suggests that a class has only one instance and keeps the
    reference to this instance in a static field.
    In RAP, <strong>this pattern is dangerous</strong>, because static values are kept in the
    <em>class</em>, which is shared among different user sessions and different applications.
    As an example, if a copy of the user's shopping cart is kept as a session singleton, this would
    work on the desktop, but in RAP, all users would share the same shopping cart instance.
  </p>
  <p>
    Instead of using singletons and static fields, all data must be kept in the correct scope in RAP.
    RAP provides a helper class <code>SessionSingletonBase</code> for creating session-unique
    instances of a given class, so called “session singletons”.
    In the context of one user session
    <code>SessionSingletonBase.getInstance( Class )</code> will always return the same object,
    but for different user sessions the returned instances will be different.
    The following code snippet illustrates this pattern: 
  </p>
  <div dir="ltr" style="text-align: left;"><pre><code>public class MySessionSingleton {
  private MySessionSingleton() {
    // prevent instantiation from outside
  }

  public static MySessionSingleton getInstance() {
    return SessionSingletonBase.getInstance( MySessionSingleton.class );
  }

  // other methods ...
}
  </code></pre></div>
  <p>
    As with the session store, it is not possible to accessing session singletons from a background thread. Any non-UI 
    thread trying to access session singletons will fail and a 
    <code>java.lang.IllegalStateException</code> will be 
    thrown. The solution is to temporarily associate the thread with a session. 
    Use <code>UICallBack#runNonUIThreadWithFakeContext</code>, to fakes a "request context" that 
    allows the runnable code to access those singletons. 
  </p>
  <p>
    The following code snippet throws an exception because the <code>Runnable</code> is executed 
    in a background thread, with no access to the session singleton. 
  </p>
  <div dir="ltr" style="text-align: left;"><pre><code>// INCORRECT
// will throw IllegalStateException: No context available outside of the request service lifecycle.
Runnable runnable = new Runnable() {
  public void run() {
    MySessionSingleton sessionSingleton = MySessionSingleton.getInstance();
    // do something with the session singleton
  }
};
new Thread( runnable ).start();
  </code></pre></div>
  <p>
    Here the <code>Runnable</code> is executed via 
    <code>UICallBack.runNonUIThreadWithFakeContext</code> which will provide the context, required 
    for accessing the session singleton.
  </p>
  <div dir="ltr" style="text-align: left;"><pre><code>// CORRECT
final Display display = Display.getCurrent();
final Runnable runnable = new Runnable() {
  public void run() {
    UICallBack.runNonUIThreadWithFakeContext( display, new Runnable() {
      public void run() {
        MySessionSingleton sessionSingleton = MySessionSingleton.getInstance();
        // do something with the session singleton
      }
    } );
  }
};
new Thread( runnable ).start();
  </code></pre></div>

</body>
</html>
