<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta name="copyright" content="Copyright (c) 2007, 2011 EclipseSource. This page is made available under license. For full details see the LEGAL in the documentation book that contains this page."/>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Custom widgets</title>
  <link rel="stylesheet" href="../../../../PRODUCT_PLUGIN/book.css" type="text/css"/>
</head>
<body>

  <h1>How to Create a Custom Widget for RAP?</h1>

  <p>
    Like in SWT, you can also create custom widgets to extend the RAP widget set to your needs.
    Examples range from simple compositions of existings controls to complex widgets such as 
    custom tab folders, or animated graphs and charts.
  </p>
  <p>
    There are different types of custom widgets which will be described below.
    But no matter which type of custom widget you implement, you will end up with an RAP widget
    that has an SWT-like API and inherits some methods from an SWT super class.
    Therefore you should make yourself familiar with some important rules of SWT before you get
    started.
    We highly recommend to read this article by the creators of SWT:
  </p>
  <ul>
    <li>
      [1] <a href="http://www.eclipse.org/articles/Article-Writing%20Your%20Own%20Widget/Writing%20Your%20Own%20Widget.htm">Writing Your Own Widget</a>
    </li>
  </ul>

  <h2>Different types of custom widgets</h2>
  <p>
    These types differ a lot with regard to the features they support, the dependency on a certain
    platform, and also the effort and knowledge it takes to create them.
  </p>

  <h3>Compound widgets</h3>
  <p>
    These are the simplest ones.
    Compound widgets are compositions of existing SWT/RAP widgets.
    These widgets have to extend <code>Composite</code>.
    There is no difference between SWT and RAP for compound widgets.
    Everything that is said about compound widgets in [1] also applies to RAP.
  </p>
  <p>
    Writing a compound widget does not require any JavaScript knowledge.</br>
    Cross-browser compatibility is ensured by RAP.</br>
    The widgets are re-usable in desktop applications with SWT.</br>
  </p>

  <h3>Self-drawing widgets</h3>
  <p>
    These are also simple in design.
    Sometimes you might want a widget that completely draws itself.
    This can be done by extending <code>Canvas</code>.
    The canvas widget supports drawing in a paint listener.
    For writing this kind of widgets, you can also follow [1].
    Please note that the drawing capabilities of RAP are limited compared to SWT.
    Especially in Internet Explorer 7 and 8, the performance degrades with the number of drawing
    operations.
  </p>
  <p>
    Writing a canvas widget does not require any JavaScript knowledge.</br>
    Cross-browser compatibility is ensured by RAP.</br>
    The widgets are re-usable in desktop applications with SWT.</br>
  </p>
  <p> 
    If performance becomes an issue and your custom widgets has layers or areas that need to be 
    redrawn considerably less often than others, you should consider combining this with the
    compound approach. Using multiple canvas widgets (stacked or in any layout), you can 
    reduce the number of operations by just painting on the canvases that need to be updated.
    Note that modern browser draw very fast, so the impact of this strategy is much less noticeable 
    than with older ones like Internet Explorer 7. (Though you also safe some traffic.)
  </p>

  <h3>Browser-based widgets</h3>
  <p>
    These can still be rather simple.
    The SWT <code>Browser</code> widget lets you place any HTML into your application.
    In RAP, this is no different. Any HTML document with JavaScript placed in a Browser widget 
    will end up in an IFrame element. This makes it easy to wrap Web 2.0 applications (a "mashup", 
    may also be based on Flash or any other Browser-PlugIn), or include existing components 
    from other JavaScript libraries. You can call JavaScript from Java by using
    <code>evaluate</code>, and vice versa with the <code>BrowserFunction</code> class.
    The drawack is that this kind of client-server communication is considerably less
    efficient that the RAP-internal Ajax architecture. (Requests may be more frequent and 
    block the UI because they are synchronous.)  
  </p>
  <p>
    Writing a Browser-based widget requires only minor-to-modarate JavaScript knowledge, unless
    you write the client component from scratch.</br>
    Cross-browser compatibility is ensured by RAP only for the Browser widget itself, but
    not for the code that is running inside it. </br>
    The widgets are re-usable in desktop applications with SWT when certain conditions apply 
    (see below).</br>
  </p>
  <p>
    Remember not to subclass <code>Browser</code> but extend <code>Composite</code> instead and
    wrap the Browser widget. This way, you do not expose the API of the Browser to user of your 
    widget, but instead provide an API that is specific for your widget. Its recommanded
    to always use <code>evaluate</code> instead of <code>executeScript</code>. Before you can use
    <code>evaluate</code>, you must wait until the document is fully loaded, using either 
    a <code>ProgressListener</code> or a <code>BrowserFunction</code>.
  </p>
  <p> 
    Each call
    to a <code>BrowserFunction</code> or to <code>evalute</code> creates a HTTP-request. 
    To reduce the resulting traffic you 
    can try combining sequential calls. A single call can transport as many information as you
    wish: <code>evaluate</code> has no limit on the number of executed JavaScript-functions. 
    <code>BrowserFunctions</code> take any number of arguments and can return several values using 
    an array of Object. 
  </p>
  <p>
    Its also important to decide how your resources (HTML JavaScript, CSS and image files) are 
    provided to the browser widget. If you use only a moderate amount of HTML with inlined 
    JavaScript and CSS (and no images), or most of your resources can be loaded from a different 
    HTTP-server, it will suffice to use the <code>setText</code> method of the browser widget.
    The resulting custom widget will also run in an SWT application. However, when using 
    <code>setText</code> the Browser can not cache the loaded document, so each new instance has 
    to load and parse it again. <i> A good example of a 
    “mashup” custom widget using this strategy is the <code>Browser</code>-based Google Maps widget[2].</i>
  </p>
  <p> 
    When a not all resources can be inlined in the HTML file (like images), and they are to be 
    provided by the RAP Application itself, there are multiple other options. 
    However, the resulting custom widget will not work in an SWT application.
    <ul>
      <li>
        Make an entire folder available via the <code>org.eclipse.equinox.http.registry.resources</code>
        extension point. This is the most simple way, but requires the 
        <code>org.eclipse.equinox.http.registry</code> bundle. <i> To see an example of this, look
        at the JQuery-Carousel widget for RAP[3].</i>
      </li>
      <li>
        Register each file using either the <code>org.eclipse.rap.ui.resources</code> extension 
        point or your <code>org.eclipse.rwt.application.ApplicationConfiguration</code>. This only 
        requires the RWT bundle itself, but necessitates creating a Java class implementing 
        <code>org.eclipse.rwt.resources.IResource</code> for each resource-file. It is therefore
        not recommanded for a larger amount of files.
      </li>
      <li>
        Accessing <code>ResourceManager</code> directly: This has some small overhead, but then requires
        only one line per registered file. All required code easily fits into your custom-widget
        class. No other bundles that RWT are required. <i>A good example for this can be found
        in the CKEdtior widget[4].</i> 
      </li>
    </ul>
  </p>
  <p>
    External Links:
	  <ul>
	    <li><!-- TODO : link to website, blog or repository?  -->
	      [2] <a href="http://eclipsesource.com/blogs/2010/12/18/a-new-google-maps-widget-for-swt-and-rap/">A new Google Maps Widget for SWT and RAP</a>.
	    </li>
	    <li>
	      [3] <a href="http://eclipsesource.com/blogs/2010/12/08/jquery-eclipse-rap-and-a-carousel/">JQuery, Eclipse RAP and a carousel</a>.
	    </li>
	    <li>
	      [4] <a href="http://eclipsesource.com/blogs/2012/03/22/ckeditor-for-rap/">CKeditor for RAP</a>.
	    </li>
	  </ul>
  </p>
  <h3>ClientScripting-enhanced widgets</h3>
  <p>
    When your custom-widget can graphically be represented by one or more existing SWT/RAP-widgets, 
    but can not be reasonably well implemented as a compound widget because of the latency of the 
    HTTP-requests involved, ClientScripting is often the ideal solution. It can also help in 
    <i>some</i> cases where certain SWT events are not implemented in RAP 
    (<code>MouseEnter</code>/<code>MouseExit</code>), or are limited compared to SWT 
    (<code>Verify</code>). ClientScripting
    is <b>not</b> to be confused with developing a native RAP custom widget. While it 
    partially runs on the client, the difference is that ClientScripting provides an SWT-like API 
    and does not require accessing RAP internals.
  </p>
  <p>
    Writing ClientScripting-enhanced widgets requires minor-to-moderate JavaScript knowledge,
    and no knowledge of any other browser technology.</br>
    Cross-browser compatibility is ensured by RAP as long as EcmaScript-standards are followed and
    no DOM-elements or RAP-internals are accessed.</br>
    The widgets are currently not innately re-usable in desktop applications with SWT. 
    However, some code can be shared between both platoforms, and the rest is easily ported.</br>
  </p>
  <p>
    ClientScripting is an RAP Incubator Project, and as of June 2012 not yet feature-complete.
    However, all existing API is stable and bugs can be reported in the RAP bugzilla. 
    Detailed information 
    can be found in the <a href = "http://wiki.eclipse.org/RAP/ClientScripting">RAP Wiki</a>,
    including some JavaScript hints and tips for Java Developer.
  </p>

  <h3>Native Custom Widgets</h3>
  <p>
    Just like in SWT, writing real native custom widgets is hard. You need deep knowledge of both 
    RAP and the platform you are developing for, i.e. the browser and any libraries you use.
    Also, in contrast to all other types of custom widgets, there is currently no guarentee
    that a native custem widget developed for one version of RAP, will work in any future versions,
    as its partially based on internal API. This is might be improved in RAP 2.0 (Kepler).
  </p>
  </p>
    We currently recommand to use any of the alternatives above. A native custom widget should
    only be required if for some reason you need to work directly with HTML/DOM API, and the 
    BrowserWidget is considered too inefficient for your usecase. 
  </p>
  <p>
    Writing a native widget may require moderate-to-advanced knowledge of JavaScript, HTML/DOM, CSS
    and any other browser-technology you might want to use, in addition to a good knowledge of 
    RAP internals. </br>
    Cross-browser compatibility has to be ensured by the widget-developer.</br>
    Native custom widgets are not re-usable in SWT desktop application unless a additional 
    SWT-specific version is being developed.</br>
  </p>
  <p>
    Detailed information for native RAP custom widget development can be found in the 
    <a href="http://wiki.eclipse.org/RAP/Custom_Widgets">RAP Wiki</a>. 
  </p>

</body>
</html>
